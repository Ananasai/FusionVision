
#include "system_app_m7.h"
#include "Camera_OV2640.h"
#include "LCD_ILI9486.h"
#include "ui_app.h"
#include "image_processing_app.h"
#include "debug_api.h"
#include "sync_api.h"
#include "shared_param_api.h"
#include "diagnostics_app.h"
#include "lepton_app.h"
#include "fonts.h"
#include <string.h>
#include "common.h"

#define __DEBUG_FILE_NAME__ "M7"

static void Printout_IRQ(void);
static bool Printout(void);

/*
 * Buffer of full screen pixels - RGB565 format.
 * This buffer is used for drawing to screen.
 */
static uint16_t image_buffer[LCD_WIDTH*LCD_HEIGTH] = {0};

typedef enum eSystemAppFlags {
	eSystemFlagFirst = 0,
	eSystemFlagFrameEvent,
	eSystemFlagLineEvent,
	eSystemFlagPrintout,
	eSystemFlagLast
}eSystemAppFlags_t;

static uint32_t system_flags = 0x00;

/*
 * How many lines received from DCMI.
 * Lines are incremented even if the data is discarded - if started reading in the middle of frame.
 * VSYNC is used for tracking the correct scanned lines.
 * Scanned lines are responsible for launching the paralelisation for image processing.
 */
static uint32_t line_scanned_amount = 0;
/*
 * Flag to track VSYNC interrups during DCMI capture.
 * Set to true every DCMI start, set to false when one IRQ from VSYNC GPIO received.
 * Used to help correctly tracking scanned lines amount.
 */
static bool first_vsync = true;

static uint32_t edge_algorithm = eEdgeAlgorithmSobel;

static const uint32_t algorithm_line_num[eEdgeAlgorithmLast] = {
	[eEdgeAlgorithmSobel] = 50,
	[eEdgeAlgorithmRoberts] = 160
};

/*
 * Init function before M4 core is started.
 */
bool System_APP_M7_PreInit(void){
	if(Sync_API_ReleaseSemaphoreAll() == false){
		return false;
	}
	if(Shared_param_API_Init() == false){
		return false;
	}
	return true;
}

/*
 * Start function executed after Init function.
 */
bool System_APP_M7_Start(void){
	/* Start debug uart */
	Debug_API_Start(huart3);
	UI_APP_Init(image_buffer);
	IMG_PROCESSING_APP_Init();
	Lepton_APP_Start();
	/* Subscribe to interrupt generated by "printout" semaphore */
	Sync_API_ActivateSemaphoreIrq(eSemaphorePrintout, Printout_IRQ);
	/* Initialise LCD screen */
	ili9486_Init();
	HAL_Delay(300);
	/* Display splash screen */
	ili9486_DrawRGBImage(0, 0, LCD_WIDTH, LCD_HEIGTH, (uint16_t *)splash_screen);
	/* Initialise OV2640 camera */
	ov2640_Init(0x60);
	/* Start time tracking for camera capture */
	Diagnostics_APP_Start();
	Diagnostics_APP_RecordStart(eDiagEventFrame);
	Diagnostics_APP_RecordStart(eDiagEventCamera);
	/* Start camera conversion */
	first_vsync = true;
	HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, (uint32_t)image_buffer, LCD_WIDTH*LCD_HEIGTH/2);
	return true;
}

/*
 * Run function executed every cycle.
 */
bool System_APP_M7_Run(void){
	/* Always run Lepton app */
	Lepton_APP_Run();
	/* Event on full frame received from DCMI */
	if(READ_FLAG(system_flags, eSystemFlagFrameEvent)) {
		CLEAR_FLAG(system_flags, eSystemFlagFrameEvent);
		Diagnostics_APP_RecordStart(eDiagEventDisplay);
		/* Draw from termo buffer on top of image_buffer */
		IMG_PROCESSING_APP_DrawTermo(image_buffer);
		/* Draw from UI to image_buffer */
		UI_APP_DrawAll();
		/* Display image to screen */
		ili9486_DrawRGBImage(0, 0, LCD_WIDTH, LCD_HEIGTH, image_buffer);
		Diagnostics_APP_RecordEnd(eDiagEventDisplay);
		Diagnostics_APP_RecordEnd(eDiagEventFrame);
		/* Check what edge algorithm selected */
		Shared_param_API_Read(eSharedParamEdgeAlgorithm, &edge_algorithm);
		Diagnostics_APP_RecordStart(eDiagEventFrame);
		Diagnostics_APP_RecordStart(eDiagEventCamera);
		/* Start recording next frame */
		line_scanned_amount = 0;
		first_vsync = true;
		HAL_DCMI_Resume(&hdcmi);
	}
	/* Event after some lines have been received from DCMI */
	if(READ_FLAG(system_flags, eSystemFlagLineEvent)){
		CLEAR_FLAG(system_flags, eSystemFlagLineEvent);
		uint32_t screen_state = 0;
		Shared_param_API_Read(eSharedParamScreenState, &screen_state);
		/* Launch image edge processing even if not the full frame is received */
		if(screen_state == eScreenStateProcessed){
			Diagnostics_APP_RecordStart(eDiagEventProcessing);
			IMG_PROCESSING_APP_Compute(image_buffer);
			Diagnostics_APP_RecordEnd(eDiagEventProcessing);
		}
	}
	/* Printout image buffer using UART */
	if(READ_FLAG(system_flags, eSystemFlagPrintout)){
		CLEAR_FLAG(system_flags, eSystemFlagPrintout);
		Printout();
	}
	return true;
}

/*
 * Printout if IRQ received from M4 core semaphore..
 */
static void Printout_IRQ(void){
	SET_FLAG(system_flags, eSystemFlagPrintout);
}

/*
 * Printout all image_buffer to debug UART.
 */
static bool Printout(void){
	for(uint16_t y = 0; y < LCD_HEIGTH; y++){
		for(uint16_t x = 0; x < LCD_WIDTH; x++){
			DEBUG_API_LOG("%d,", NULL, NULL, *(image_buffer + x + y * LCD_WIDTH));
			/* make sure to print new line every x amount of characters */
			if(x % 120 == 0){
				DEBUG_API_LOG("\r\n", NULL, NULL);
			}
		}
		DEBUG_API_LOG("\r\n", NULL, NULL);
	}
	return true;
}

/*
 * DCMI full frame received IRQ.
 */
void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi){
	HAL_DCMI_Suspend(hdcmi);
	Diagnostics_APP_RecordEnd(eDiagEventCamera);
	SET_FLAG(system_flags, eSystemFlagFrameEvent);
}
/*
 * Used to reset line amount after first vsync - because lines keep getting calculated
 * even when dcmi is suspended and after wakeup it is waiting for new frame start - vsync
 * to capture data
 */
void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi){
	if(first_vsync){
		line_scanned_amount = 0;
		first_vsync = false;
	}
}
/*
 * DCMI line captured event - launch image processing in the middle of frame.
 */
//TODO: big improvement if line repsonse set at 3, find out why
void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi){
	line_scanned_amount++;
	if(first_vsync == false){
		if(line_scanned_amount == algorithm_line_num[edge_algorithm]){
			SET_FLAG(system_flags, eSystemFlagLineEvent);
		}
	}
}
